import 'package:flutter/material.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:uuid/uuid.dart';
import 'package:veil/models/note_model.dart';
import 'package:path_provider/path_provider.dart';
import 'dart:io';

class NoteService extends ChangeNotifier {
  static const String _notesBoxName = 'notes';
  
  late Box<Note> _notesBox;
  late List<Note> _notes;
  final _uuid = Uuid();
  
  List<Note> get notes => _notes;
  
  Future<void> initialize() async {
    // Register adapter if not registered
    if (!Hive.isAdapterRegistered(7)) {
      Hive.registerAdapter(NoteAdapter());
    }
    
    // Open box
    _notesBox = await Hive.openBox<Note>(_notesBoxName);
    
    // Load notes
    _notes = _notesBox.values.toList();
    
    // Sort by updated time (newest first)
    _notes.sort((a, b) => b.updatedAt.compareTo(a.updatedAt));
  }
  
  Future<Note> createNote({
    required String title,
    required String content,
    String sourceUrl = '',
  }) async {
    final id = _uuid.v4();
    final note = Note(
      id: id,
      title: title,
      content: content,
      sourceUrl: sourceUrl,
    );
    
    await _notesBox.put(id, note);
    
    _notes = _notesBox.values.toList();
    _notes.sort((a, b) => b.updatedAt.compareTo(a.updatedAt));
    
    notifyListeners();
    
    return note;
  }
  
  Future<void> updateNote(Note note) async {
    note = Note(
      id: note.id,
      title: note.title,
      content: note.content,
      sourceUrl: note.sourceUrl,
      createdAt: note.createdAt,
      updatedAt: DateTime.now(),
    );
    
    await _notesBox.put(note.id, note);
    
    _notes = _notesBox.values.toList();
    _notes.sort((a, b) => b.updatedAt.compareTo(a.updatedAt));
    
    notifyListeners();
  }
  
  Future<void> deleteNote(String id) async {
    await _notesBox.delete(id);
    
    _notes = _notesBox.values.toList();
    _notes.sort((a, b) => b.updatedAt.compareTo(a.updatedAt));
    
    notifyListeners();
  }
  
  Note? getNote(String id) {
    return _notesBox.get(id);
  }
  
  List<Note> searchNotes(String query) {
    if (query.isEmpty) {
      return _notes;
    }
    
    final lowercaseQuery = query.toLowerCase();
    
    return _notes.where((note) {
      return note.title.toLowerCase().contains(lowercaseQuery) ||
             note.content.toLowerCase().contains(lowercaseQuery);
    }).toList();
  }
  
  Future<String> exportNoteAsMarkdown(String id) async {
    final note = getNote(id);
    if (note == null) {
      throw Exception('Note not found');
    }
    
    final directory = await getApplicationDocumentsDirectory();
    final fileName = '${note.title.replaceAll(' ', '_')}.md';
    final file = File('${directory.path}/$fileName');
    
    final markdown = '''
# ${note.title}

${note.content}

---
Source: ${note.sourceUrl}
Created: ${note.createdAt.toIso8601String()}
Last Updated: ${note.updatedAt.toIso8601String()}
''';
    
    await file.writeAsString(markdown);
    
    return file.path;
  }
  
  Future<String> exportAllNotesAsMarkdown() async {
    final directory = await getApplicationDocumentsDirectory();
    final fileName = 'veil_notes_export_${DateTime.now().millisecondsSinceEpoch}.md';
    final file = File('${directory.path}/$fileName');
    
    final buffer = StringBuffer();
    
    for (final note in _notes) {
      buffer.writeln('# ${note.title}\n');
      buffer.writeln('${note.content}\n');
      buffer.writeln('---');
      buffer.writeln('Source: ${note.sourceUrl}');
      buffer.writeln('Created: ${note.createdAt.toIso8601String()}');
      buffer.writeln('Last Updated: ${note.updatedAt.toIso8601String()}');
      buffer.writeln('\n\n');
    }
    
    await file.writeAsString(buffer.toString());
    
    return file.path;
  }
}

// This adapter class will be generated by build_runner
class NoteAdapter extends TypeAdapter<Note> {
  @override
  final int typeId = 7;

  @override
  Note read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    
    return Note(
      id: fields[0] as String,
      title: fields[1] as String,
      content: fields[2] as String,
      sourceUrl: fields[3] as String,
      createdAt: fields[4] as DateTime,
      updatedAt: fields[5] as DateTime,
    );
  }

  @override
  void write(BinaryWriter writer, Note obj) {
    writer
      ..writeByte(6)
      ..writeByte(0)
      ..write(obj.id)
      ..writeByte(1)
      ..write(obj.title)
      ..writeByte(2)
      ..write(obj.content)
      ..writeByte(3)
      ..write(obj.sourceUrl)
      ..writeByte(4)
      ..write(obj.createdAt)
      ..writeByte(5)
      ..write(obj.updatedAt);
  }
}